:bulb: ***Later equals never.***



#### 1.有意义的命名

软件中随处可见命名，我们给变量、函数、类和包命名，下面是起一个好名字应该遵从的规则。



==名副其实==

选个好名字要花时间，但是省下来的时间比花掉的多，注意命名，而且一旦发现有更好的命名就换掉旧的，这样做，读代码的人都会更开心。

1. 指明计量单位和计量单位的名称，如：int elapsedTimeInDays、int fileAgeInDays 等。

2. 选择体现业务本意的名称，而不是字母（如：d、e），类型（如：theList、list1）等名称。

3. 利用类代替复杂的数据结构。

   例如：应用中使用 int\[]\[] 数组表示坐标，如果在代码中大量使用这个二维数组，代码会变得极其繁杂，我们可以定义一个类

   ~~~java
   public class Position {
       private int value;
       private int x;
       private int y;
   }
   ~~~

4. 避免使用魔术变量（未经定义的常量），例如：

   ~~~java
   if(age == 5){
       // do something
   }
   ~~~

   此时，我们应当将 5 这个魔术数放到文件前面并定义一个数字，如：`private static final int MIN_AGE = 5;`。



==避免误导==

程序员必须避免留下掩藏代码本意的错误线索，避免使用与本意相悖的词。

1. 避免使用某些专有名称作为变量名，例如：aix、sco、bat 等，虽然看起来像是不错的缩写，但是极易引起误导。
2. 不要使用 accountList 来表示一组账号，除非它真的是 List 类型，否则会引起错误的判断，此时使用 accountGroup 或 accounts 都是更好的选择。
3. 不要使用外形相似度较高的名称，例如 XYZControllerForEfficientHandlingOfStrings 和 XYZControllerForEfficientStorageOfStrings，更有甚者使用小写的字母 l 和大写的字母 O，他们看起来完全像常量「壹」和「零」。



==做有意义的区分==

在代码中，同一作用范围的两样不同的东西不能重名，如果我们只是为满足编译器或解释器的需要而修改代码，那么将会带来无尽麻烦。

1. 只是在命名后添加数字远远不够，每个不同的命名都应该能表达出不同的意义，如 a1、a2、a3、a4... 等名称纯属误导，完全没有提供正确的信息，例：

   ~~~java
   public void copyChars(char[] c1, char[] c2) {
       for (i = 0; i< c1.length; i++) {
           c2[i] = c1[i];
       }
   }
   ~~~

   此时，两个参数名 c1 和 c2 完全没有任何意义，如果将其替换为 source 和 destination，函数就会好看许多。

2. 避免使用废话来区分命名，假设有一个 Product 类，还有一个 ProductData 和 ProductInfo 类，那么它们虽然名称不同，但是都是意义含混的废话；当我们面对 getActiveAccount、getActiveAccounts 和 getActiveAccountInfo 这 3 个函数时，也无法快速的分辨到底该调用哪一个函数。

3. 避免冗余的命名，例如 variable 永远不要出现在变量名中，table 永远不要出现在数据库表名中，nameString 也不会比 name 更好。



==使用读得出来的名称==

人类擅长于记忆和使用单词，如果名称读不出来，在讨论的时候就会变得十分尴尬。

1. 不要使用字母组合命名，例如程序里面有一个 genymdhms 函数（生成年月日时分秒），这样的函数名完全无法读出来也无法一眼看出它的含义，如果换成 genTimestamp 这样的命名就会使函数读起来更像人话。

2. 不要使用不恰当的缩写，例如：DtaRcrd、Cstm、Acct 并不会比 DataRecord、Customer、Account 这些完整的单词更好更简洁。

   

==使用可搜索的名称==

对于单字母名称和数字常量，有一个问题就是很难再一大段代码中搜索出来。

1. 搜索 MAX_CLASSES_PER_STUDENT 很容易，但是查找数字 7 就比较麻烦了，同时字母 e、s 等也不是一个便于搜索的好名称，我们应该尽量避免使用单字母名称和数字常量。
2. 名称长短应该与其作用域大小相对应，如果变量或常量可能在代码中多处使用，则应该赋予它们便于搜索的名称。



==避免使用标记==

现代编程语言有丰富的类型系统，并且强制使用类型，所以把类型和作用域编进名称里面，只会突然增加负担。

1. 不必使用 m_ 来标记成员变量，我们要学会无视前缀或后缀，只看到名称中有意义的部分。
2. 在创建接口时，不要使用前导字母 I，比如 IShapeFactory 对于 ShapeFactory 来说，前面的 I 字母根本就是一句废话。



==类名和方法名==

1. 类名和对象名应该是名称和名词短语，例如 Customer、Account 等，此外还要避免使用 Data、Info、Manager 这样语义广泛的名称。
2. 方法名应当是动词或动词短语，如 postPayment、deletePage 等。



==一词一义==

1. 每个概念值对应一个词，假如一堆代码中的控制器有 controller、manager 和 driver，name就会让人产生困惑，我们的命名应当一以贯之。
2. 避免将同一单词用于不同目的（双关），例如：使用 add 用于向集合中添加元素，而在另外的地方用来拼接字符串，这种做法是强烈禁止的。



==使用解决方案领域名称和问题领域名称==

1. 只有程序员才会读你的代码，所以我们可以尽情的使用那些计算机科学术语，算法名，模式名，没有程序员不知道 AccoutVisitor 的含义，同样，大多数程序员也都了解 JobQueue 的含义。
2. 如果不能使用程序员熟悉的术语进行命名，那么可以考虑从所涉及的问题的领域获取命名，与软件的实际功能更为贴近。



==为代码添加语境==

很少有名称是能够自我说明的，如果不能自我说明，我们还剩最后一招，给名称添加前缀语境。

1. 当我们看见一堆单词如 state、city、street、name、houseNumber 时，我们很容易推断这是一个地址的描述，但是如果我们只看见一个孤零零的 name 变量呢，我们无法进行推断，但是我们可以添加前缀进行说明：addrName，这样我们就可以明白这个变量是更大结构的一部分。
2. 当需要使用到一堆相关联的变量时，可以使用一个类封装它们，类也是语境的一部分。
3. 不要添加无意义的语境，假如有一个名为 Gas Station Deluxe（加油站豪华版）的应用，如果给其中的每一个类都加上 GSD 前缀就不是什么好点子了；只要名称足够清楚，短名称就比长名称好。



---

#### 2.函数

在编程的早期岁月，系统由程序和子程序组成，后来到了 Fortran 和 PL/1 的年代，系统由程序、子程序和函数组成，如今只有函数保留了下来，函数是所有程序中的第一组代码。



==短小==

函数的第一条规则是短小，第二条规则还是要短小。

1. 函数尽量不要写得过长，**20** 行封顶最佳。

   > :gear: 个人不倾向于这这么短的函数，频繁的函数调用不仅不会降低代码编写难度，还会提高难度。一般情况下，**50-60** 行左右封顶为最佳。

2. if、else、while 等语句，其中的代码应该只占一行，该行一般为一个函数调用语句，这样能够很好的保持函数大小。

3. 函数中的代码嵌套层级（if、while 等嵌套）不宜过多，否则不易于阅读和理解，最好是一层或两层，不可超过三层。



==只做一件事==

函数应该只做一件事，做好这件事，只做一件事。

如何判断函数只做了一件事，还是做了几件事？例：

~~~java
public void buy() {
    // 1.走进商店
    // 2.选好商品
    // 3.掏出钱包
    // 4.付钱
    // 5.放回钱包
    // 6.走出商店
}
~~~

在这个函数中，模拟了一个买东西的情节，其中 1、2、6 步骤都是买东西过程下的抽象层中的一件事，但是 3、4、5 却是在买东西这个动作下的更细分的步骤，很明显不属于函数名下的抽象层，此时 3、4、5 就合一被拆出一个新函数「结账」。

> :yellow_heart: 向下原则：让每个函数后面跟着位于下一抽象层及的函数，在阅读时就能遵循抽象层级向下阅读。





==使用具有描述性的名称==

为函数起一个具有描述性的名称，函数的功能越集中，就越便于起一个好名字。

不要害怕长名称，长名称要比短而费解的短名称好。

在同一个模块中，函数的命名方式要保持一致，使用与模块名一脉相承的短语、名词和动词给函数命名。



==函数参数==

最理想的函数参数是 0，其次是 1，再次是 2，应当尽量避免 3 参数的函数（除非万不得已）。

1. 一般来说，信息通过参数输入函数，然后通过返回值进行输出，所以尽量不要在参数中输出函数结果。

2. 不要使用标识参数：向函数输入 boolean 值是一种不优雅的做法，相当于大声宣布本函数不只做一件事，在任何情况下我们都不要这样做；此时我们应该将这种情况拆分为 2 个函数 doXxxForXxx 和 doXxxForNonXxx。

3. 双参数函数：

   1. 两个参数最好是某个值的有序组成部分，如：`new Point(0, 0);`。
   2. 使用两个同类型的参数时，应额外注意其先后顺序，如：`assertEquals(expected, actual);`中一般约定期望值在前，实际值在后。
   3. 尽量的转化双参数函数为单参数函数，可以使用诸如添加成员变量、新建一个类等方法。

4. 三参数函数：如果一个函数看起来需要 2 个、3 个及 3 个以上的参数，说明一些参数应该封装成类了，例：

   ~~~java
   Circle makeCircle(double x, double y, double radius);
   Circle makeCircle(Point center, double radius);
   ~~~

5. 可变参数：在 Java 中，可以使用 ... 向函数传入可变长度的参数。

6. 函数和参数应当形成一种非常良好的动词/名词的对应关系，例如： `writeField(name);`。



==分割指令和询问==

1. 函数要么做什么事，要么回答什么事，两者不可得兼，例：

   ~~~java
   boolean isSuccess = setAttribute("username", "unclebob");
   ---------------------------------------------------------
   if(attributeExists("username")) {
       setAttribute("username", "unclebob");
   }
   ~~~

   此两种代码明显后者更优。

2. 使用异常替代返回错误码，将询问以异常的形式抛出，能够很好的分割指令和询问。
   1. 将 try/catch 代码块单独抽离为一个函数，使之从主代码块中分离出来，代码就会变得更简洁。
   2. 错误处理就是一件事，处理错误的函数不应该做其他的事，如果在抛出错误的时候需要做另外的一件事，那么应该好好考虑此处是否应该抛出错误。
   3. 尽量使用异常代替错误码，返回错误码一般是一个枚举类，其他许多类都要依赖并使用它，使得在修改这个枚举类时造成了很大的负面压力，所以，尽量使用异常派生类。



---

#### 3.注释

注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。

注释会撒谎；我们的代码在变动，在演化，但是注释不总是随之变动，只有代码才能忠实的告诉你它在做的事情。

好助手是必需的，是有利的；尽管我们需要注释，但是我们也应该多花心思尽量减少注释量。



==好注释==

1. 法律信息：有时，公司代码规范每个源文件开头放置与法律相关的注释，如版权与著作声明：

   ~~~java
   // Copyright (c) 2003,2004,2005 by Object Mentor,Inc. All rights reserved.
   ~~~

   注意：此类注释不应该是合同或法典，只要有可能，就应该指向一份标准许可或外部文档。

2. 对意图的解释：对某段代码的目的作出解释。

3. 阐释：对某些晦涩难懂的方法的返回值，变量值的意义翻译为可读形式。

4. 警示：对调用代码的程序员作出相应的警示，如：

   ~~~java
   // SimpleDateFormat is not thread safe, so we need to create each instance independently.
   ~~~

5. TODO 注释：TODO 是程序员认为该做，但是由于某个原因目前还没有完成的工作，同时，我们也要定期查看，删除不必要的 TODO 注释。

6. 放大：可以用来放大在某处看起来不合理的代码的重要性。

7. 公共 API 的 Javadoc。



==坏注释==

1. 喃喃自语：如果只是因为觉得应该写注释或者是过程需要就添加注释，那就是无谓之举。

2. 误导性注释：当代码的行为与注释描述不符时，那就是误导性注释。

3. 循规式注释：不是每个函数都需要添加 Javadoc 注释，也不是每个变量都需要注释，否则就会让代码变得散乱。

4. 日志型注释：有人会在每次编辑代码时在模块开始处添加一段注释，此种注释维护困难，大可不必。

5. 废话注释：在某些简单的函数或变量上添加自述一般的注释纯属废话注释。

6. 位置标记，如：

   ~~~java
   // Actions ---------------------------------
   ~~~

7. 括号后面的注释：有时候我们会在括号后面放置注释用来标记括号的结束，但是此时我们更应该做的是缩小括号。

8. 署名信息，如：`//Added By David`。

9. 注释掉的代码：现在我们有良好的源代码控制系统（Git、SVN）帮助我们记住写过的代码，对于不需要的代码块，直接删除即可。

10. 非本地信息：假如你一定要写注释，请确保它描述了离它最近的代码。

11. 过多的注释：不要在注释中添加不必要的细节信息和其他话题。

12. 不明显的联系：如果一定要写注释，那么请确保注释描述和代码之间保持显而易见的联系。

13. 非公共代码的 Javadoc：如果代码并不打算用作公共用途，那么请尽量减少 Javadoc 注释。



---

#### 4.格式

垂直尺寸：通过对各个开源系统代码的总结，我们用大多数为 **200**，最长不超过 500 行的单个文件可以构造出较为出色的系统。

垂直格式：

1. 源文件要像报纸一样，名称应当简单且一目了然，源文件顶部应该给出高层次的概念和算法，细节向下渐次展开。
2. 在垂直方向上，每组代码使用空白行区隔开来。
3. 在垂直方向上，紧密相关的代码应该互相靠近（如类的各个属性值）。
4. 垂直距离：
   1. 关系密切的概念应当相互靠近，除非有很好的理由，否则不要把关系密切的概念放置在不同的文件中。
   2. 变量声明：变量声明要尽可能地靠近其使用位置。
   3. 实体变量：实体变量应该在类的顶部进行声明。
   4. 相关函数：若某个函数调用了另一个，就应该把它们放在一起，而且调用者应该尽可能地放在被调用者的上面。



横向尺寸：我们应当尽力保持代码短小，，一般来说尽量保持无需左右拖动滚动条就可以看到最右边代码的原则（120 字符左右为最佳）。

横向格式：

1. 水平方向上的区隔：

   1. 赋值符号两边加空格以区隔。
   2. 函数体 `{}` 与函数声明和参数间加一个空格以区隔。
   3. 使用空格强调运算符，如：`a = b*b - 4*a*c`，乘法之间不加空格，因为它们的优先级较高，减法间使用空格进行区分。

   

---

#### 5.对象和数据结构

对象和数据结构：

1. 对象：对象把数据隐藏于抽象之后，暴露操作数据的函数。

   ~~~java
   public class Square implements Shape {
       private Point topLeft;
       private double side;
       
       public double area() {
           return side*side;
       }
   }
   --------------------------------------------
   public class Circle implements Shape {
       public static final double PI = 3.1415926;
       private Point center;
       private double radius;
   
       public double area() {
           return PI*radius*radius;
       }
   }     
   ~~~

2. 数据结构：数据结构暴露其数据，不提供有意义的函数。

   ~~~java
   public class Square {
       public Point topLeft;
       public double side;
   }
   --------------------------------------------
   public class Circle {
       public Point center;
       public double radius;
   }
   --------------------------------------------
   public class Geometry {
       public static final double PI = 3.1415926;
       
       public double area(Object shape) throws NoSuchShapeException {
           if(shape instanceof Square) {
               Square s = (Square) shape;
               return s.side*s.side;
           }else if(shape instanceof Circle) {
               Circle c = (Circle) shape;
               return PI*c.radius*c.radius;
           }else {
               throw new NoSuchShapeException();
           }
       }
   }
   ~~~

我们将代码 [1] 称为面向对象的代码，而代码 [2] 则为过程式代码。

如果我们需要给 [2] 中的 Geometry 添加一个 primeter() 函数，这些形状类根本不会受到影响，另一方面，如果我们添加一个新形状，那么需要修改 Geometry 中所有的函数来处理它。

代码 [1] 与代码 [2] 恰恰相反，如果需要添加一个新形状，原来的形状类不会受到任何影响；但如果接口需要添加一个新函数，所有形状类都需要做出相应修改。

所以：==过程式代码（使用数据结构的代码）便于在不改动既有数据结构的情况下添加新函数；面向对象代码便于在不改动既有函数的情况下添加新类==。



**得墨忒耳定律** －－ 对象 O 的 M 方法，可以访问/调用如下的：

1. 对象 O 本身。
2. M 方法的传入参数。
3. M 方法中创建或实例化的任意对象。
4. 对象 O 直接的组件对象。
5. 在 M 范围内，可被 O 访问的全局变量。

方法不应该调用由任何函数返回的对象的方法（只跟朋友谈话，不跟陌生人谈话）。例：

~~~java
final String outputDir =  ctxt.getOptions().getScratchDir().getAbsolutePath();
~~~

此段代码是否违背了得墨忒耳定律？

1. 如果 ctxt、Options 和 ScratchDir 是对象，则它们的内部结构应当被隐藏，显然违反了得墨忒耳定律。

2. 如果 ctxt、Options 和 ScratchDir 只是单纯的数据结构，没有任何行为，此段代码可以看作：

   ~~~java
   final String outputDir =  ctxt.options.scratchDir.absolutePath;
   ~~~

   只是数据结构在暴露其内部数据，不算做调用 ctxt 的任何行为方法。

> :yin_yang: 有时候我们会使用混杂的结构，即一般是对象，一半是数据结构；此种结构增加了添加新函数的难度，也增加了添加数据结构的难度，两头不讨好；同时对于各种规则定律的判断产生误导，应当避免创造这种结构。

那么，如果 ctxt 是对象，此段代码应该如何修改呢？
既然 ctxt 是对象，就应该要求它做点什么，所以，这件事不妨交给 ctxt 对象本身来做：

~~~java
final String outputDir =  ctxt.createAbsolutePathOfScratchDirOption();
~~~

此时，既没有暴露 ctxt 的内部细节，也没有违反得墨忒耳定律。



> 在任何系统中，有时我们希望能够灵活地添加数据类型，所以更喜欢在这部分使用对象。另外的一些时候，我们希望能够灵活地添加新行为，这时候我们更希望使用数据类型和过程代码。
>
> 优秀的程序员能够不带成见地了解这两种情形，并依据手中的工作性质选择一种合适的手段。



---

#### 6.错误处理

> :baby_chick: 错误处理是编程时必须要做的事情之一，错误处理很重要，但如果它搞坏了代码逻辑，那就是错误的做法。



Java 代码中的错误处理：

1. 使用异常而非返回码。

2. try-catch-finally 语句的使用：

   1. 在明明白白地知道自己的代码会发生错误时，再使用 try-catch 语句就不太合适了。例如：如果传递给函数的参数是字符串而非数值，就会造成函数出错，那么就应该先检查参数的类型，然后再决定如何去做。      
   2. 在 catch 块中，可以对错误进行处理，也可以在处理过后在抛出一个缩小异常类型范围的新异常。
   3. 尝试编写强行抛出异常的代码，再想处理器中添加行为，结果就是你需要先构造 try 代码块的事务范围，可以帮阻尼维护好该范围的事务特征。

3. 使用未检异常：如果你在代码中抛出已检异常时，当 try-catch 语句的调用层级很高时，意味着你需要你在调用的每个方法签名上声明该异常，此点违背了 [开放/闭合原则]。

   如果我们在编写一些关键的代码库，已检异常有时也会有用，但是对于一般的应用开发，未检异常更加好用。

4. 给出异常发生的环境说明：在抛出异常时应创建充分的错误信息，并和异常一起传递出去。

5. 在引用第三方代码时，我们可以将第三方的异常打包，抛出自己的异常进行解释。

6. 定义常规流程：如果某一个业务因为某种特例抛出错误而中断了业务流程，我们可以考虑创建或配置一个特例对象来处理这种情况。

7. 不要返回 null 值和传递 null 值。



---

#### 7.类

类的组织：遵循 Java 的约定，类应该从一组变量列表开始；

​	变量的出现顺序为：公共静态常量 --> 私有静态变量 --> 私有实体变量。



类应该短小：对于函数，我们通过计算代码行数衡量其大小；对于类，我们采用权责（responsibility）进行衡量。

1. 类的名称应当描述其权责，如果无法为某个类命以精确的名称，那么大概这个类就太长了。

2. 单一权责原则（**SRP**）：类或模块应该有且只有一条加以修改的理由。

   > :desert_island: 系统应该由许多短小的类而不是少量巨大的类组成，每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。

3. 内聚：类应该只有少数实体变量，类中的每个方法都应该操作一个或多个这种变量。一般来说，方法操作的变量越多，就越粘聚在类上。

   > :balloon: 保持函数和参数列表短小的策略，有时会导致一组子集方法所用的实体变量数量增加，出现这种情况时，往往意味着至少有一个类要从大类中挣扎出来，我们应当将这些变量和方法拆分到两个或多个类中，使新的类更加内聚。

4. 面向修改关闭：需求会改变，所以代码也会改变；具体类包含实现细节，而抽象类只呈现概念，依赖具体细节的实现类，当细节改变时，就会有风险。我们可以借助接口和抽象类来隔离这些细节所带来的影响。

   > :aerial_tramway: 通过接口和抽象类，也对系统的部件进行了解耦，也就遵循了另一条类设计原则，及依赖倒置（Dependency Inversion Principle）原则。



---

#### 8.系统

> :rabbit2: 软件系统应将起始过程和起始过程之后的运行时逻辑分开。在起始过程中创建应用对象，也会存在着互相缠结的依赖关系。

将系统的构造和使用分开的方法：

1. 分解 main：将全部的构造过程搬迁到 main 方法或者被称之为 main 的模块之内，设计系统的其余部分时，假设所有的对象都已经正确构造和设置。

2. 工厂：使用工厂创建对象，应用程序能够决定何时创建对象，单创建对象的过程隔离与工厂之内。

3. 依赖注入：将第二权责（构造）从对象当中拿出来，转移到另一个专注于此的对象中，从而遵循了单一权责原则。

   > :zzz: 真正的依赖注入还需要更进一步，类并不直接解决依赖问题，而是保持完全被动，它提供用于注入依赖的赋值器或构造器，由容器在恰当的时候创建需要的对象。



扩容：与物理系统相比，软件系统比较独特，软件系统的架构可以递增式的增长，只要我们持续将关注面恰当的切分。

横贯型关注面：在代码实践中，我们不得不将同种代码铺展到许多对象中，我们用横贯型关注面来形容这种情况。

面向切面编程（AOP）：将横贯型关注面模块化的手段，目前主要包含以下 3 种机制

1. Java 代理：Java 代理适用于简单情况，将单独的对象或类中包装方法调用。
2. 纯 Java AOP 框架：如 Spring AOP 和 JBoss AOP，通过在 xml 中定义所有的实体 bean，将应用程序的构造和使用进行分离。
3. AspectJ：AspectJ 提供了一套用以切分关注面的强有力的工具，Spring 中也对 AspectJ 进行了组合。



---

#### 9.迭进

Kent Beck 提出了关于简单设计的 4 条规则：

1. 运行所有测试
2. 不可重复
3. 表达程序员的意图
4. 尽可能的减少类和方法的数量

以上规则逐条迭进，只要遵循以上规则，设计就能变得简单。



运行所有测试：设计必须制造出如预期一般工作的系统，这是首要因素。



规则 2-4（重构）：要保持代码的整洁，方法就是递增式的重构代码。

1. 消除重复：重复有多种表现，雷同的代码是重复的代码，类似的代码也可以调整得更相似，这样能更容易的进行重构。

   > 还有一些其他方式的重复，例如某个类存在两个方法：
   >
   > ~~~java
   > int size();
   > boolean isEmpty();
   > ~~~
   >
   > 这两个方法可以分别实现，但是我们也可以通过在 isEmpty 方法中使用 size 来消除重复：
   >
   > ~~~java
   > boolean isEmpty() {
   >     return 0 == size();
   > }
   > ~~~

   ==模板方法模式是一种消除高层及重复的通用技巧。==



---

#### 10.并发编程

并发是一种解耦策略，它帮助我们将做什么和何时做分解开，并明显的改进程序的吞吐量和结构。



为了正确的并发，有一系列的防御并发代码的原则和技巧：

1. 单一权责原则：并发代码有自己的开发，修改和调优的生命周期。并发代码有自己要应对的挑战，而且往往更为困难。

   建议：分离并发相关代码和其他代码。

2. 限制数据作用域：谨记数据封装，严格限制对可能被共享的数据的访问。

3. 使用数据副本：通过复制数据副本来减少减少可能因为共享数据而导致错误的可能性。

4. 线程应尽可能的独立：尝试将数据分解为可独立线程操作的独立子集。



> :japanese_goblin: Java 并发库：java.util.concurrent，java.util.concurrent.atomic，java.util.concurrent.locks



多线程代码应当注意的原则：

1. 保持同步区域微小：锁是昂贵的，它带来了延迟和额外开销，所以我们应尽可能的减小同步区域。

2. 编写正确的关闭代码：尽早地考虑关闭问题，尽早令其正常工作。

3. 测试线程代码：编写有潜力暴露问题的测试，在不同的编程配置，系统配置和负载条件下反复运行测试。

   1. 不要讲系统错误归结于偶发事件。

   2. 先使非线程代码可以正常工作，不要同时追踪非线程缺陷和线程缺陷。

   3. 编写可拔插的线程代码，这样就能在不同的配置环境下运行。

   4. 运行多于处理器核心数量的线程，促使任务交换的发生，更快的暴露线程问题。

   5. 在不同的平台上运行测试。

   6. 装置试错代码：例如向代码中加入 wait(); sleep(); yield() 等的调用来进行测试。

      

附录 A





---

#### 11.逐步改进（案例）